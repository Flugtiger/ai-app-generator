General requirements for a clean domain model that you MUST follow:
- use pydantics `BaseModel` as the base for all classes that need to be serialized (e.g. aggregates)
- use pydantic V2 syntax
- Classes whose objects are interchangeable if they contain the same values are 'Value Objects'. They MUST NOT contain an 'id' field. Two Value Objects are considered identical if they contain the same values.
- Classes that have an identity that is separate from the values inside the class, are 'Entities'. Only Entities contain a field 'id'.
- Entities can contain Value Objects and other Entities. This can form a tree structure. One such tree is called 'Aggregate'. The Entity at the root of the tree is called 'Aggregate Root'. All interactions with an Aggregate MUST happen through the Aggregate Root.
- Verbs in the requirements become methods on Entities and Value Objects and implement the domain logic. Only generate methods for the verbs mentioned in the requirements. Only implement implied functionalities, if this functionality is used somewhere.
- Classes that do not contain state but rather orchestrate actions between multiple Aggregates or Value Objects are Domain Services. Domain Services can reference each other to implement complex tasks.
- When a Domain Service needs additional technology or an external service to do its task (i.e. its task is not part of the context of the application you are building), it should be abstract.
- IDs have their own, aggregate-specific value object classes that wrap a simple string
- You MUST leave the ID empty when a new aggregate object is instantiated
- The real ID for new objects is generated and set in the infrastructure code. You MUST NOT implement this logic as part of the domain model!
- Aggregates must only reference other Aggregates via the ID of the Aggregate Root
- each Aggregate MUST have a Repository
- a Repository MUST be abstract (the implementation is not part of the domain model)
- a Repository MUST have at least the methods `get_by_id`, `save` and `get_all`
- if there is a Value Object for a specific type of data, use it everywhere that data type is needed (method parameters, class fields, return types)
- make assertions about the Aggregate state according to the business rules before the actual code in the methods of an Aggregate
- use enums to restrict values
- Aggregates and Value Objects must not depend on or call Domain Services!
- you MUST NOT write any infrastructure code, example code or anything else that should not be part of a technology-free domain model
- everything that can be implemented by using the base library of the programming language is considered as technology-free
- you MUST NOT implement abstract(!) domain services since their implementation will be part of the infrastructure code, you still MUST write the abstract class to specify their interface
- you MUST put all files inside the folder "src/model", e.g. "src/model/<domain-category>/aggregate_name.py" or "src/model/<domain-category>/domain_service.py".
- use terms from the domain language for the names of the folders, keep Aggregates and their IDs and Repositories together, put different types of services into different folders
