General requirements for a clean DDD model that you MUST follow:
- use pydantics `BaseModel` as the base for all classes that need to be serialized (e.g. aggregates)
- use pydantic V2 syntax
- IDs have their own value object class that wraps a simple string
- You MUST leave the ID empty when a new aggregate object is instantiated
- The real ID for new objects is generated and set in the infrastructure code. You MUST NOT implement this logic as part of the domain model!
- aggregates must only reference other aggregates via the ID of the aggregate root
- generate a Repository for each Aggregate
- a Repository MUST be abstract (the implementation is not part of the model)
- a Repository MUST have at least the methods `get_by_id`, `save` and `get_all`
- if an object is to be created from an existing object, put a factory method in the class of the existing object, e.g. if a House is needed to create an Apartment, it should be possible to write: house.create_apartment(...), this factory method should call the constructor of the class of the object to be created, not another wrapper!
- make assertions about the model state before the actual code in the model methods
- use enums to restrict values
- aggregates and value objects must not depend on or call domain services!
- you MUST NOT write any infrastructure code, example code or anything else that should not be part of a technology-free domain model
- everything that can be implemented by using the base library of the programming language is considered as technology-free
- you MUST NOT implement abstract(!) domain services since their implementation will be part of the infrastructure code
- You MUST put all files inside the folder "src/model", e.g. "src/model/<aggregate_name>/aggregate_name.py" or "src/model/services/domain_service.py".
